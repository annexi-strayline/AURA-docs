Autoconfiguration
=================

One common need for portable code "packages" is the configuration of various platform-dependent values.

The design intent is for this kind of platform-specific configuration process to be as integrated as possible, and not simply pull from existing C/UNIX-oriented autoconfiguration systems like Autotools, Ninja/CMAKE, etc.

To this end, all AURA auto-configuration happens among a special AURA-specific Ada subsystem which contains all AURA subsystem configuration, platform information, and repository configuration, within normal Ada packages.


The AURA Subsystem
------------------

All configuration and autoconfiguration is carried out through the packages that constitute the AURA subsystem.

The root package (package AURA) is automatically generated by the AURA implementation, has the aspect Pure, and has no body. 

The root package defines the implementation-defined enumeration type Repository_Type that determines the types of :doc:repositories supported by the implementation, as well as a standardized set of platform values.

An example root spec from the reference implementation looks something like this:

.. literalinclude:: snippets/aura.ads
  :language: ada
  :caption: aura.ads

Any AURA subsystem can with the AURA root package to gain access to these values, and use these to configure different parts of codebase, based on the platform the subsystem gets built on.

Of course there are limitations to how much of this configuration can be done from within Ada, particularly when including non-Ada sources. To handle these situations, AURA specifies a rich *autoconfiguration* mechanism that allows AURA subsystems to self-configure on build.

Subsystem Manifests
-------------------

Each AURA subsystem can *optionally* include a special library unit called the **AURA manifest**. This is an Ada package that is the first child of the subsystem itself, with a name of "AURA". For example, for a the CLI subsystem in our :doc:`quick start example </quick_start/using_an_aura_package>`, the **AURA manifest** would be declared like this:

.. code-block:: ada

  package CLI.AURA is
    ..

If included, manifests are copied to the project root as-is (spec and body), except that they are renamed as direct children of the AURA package with the subsystem name. As with the root AURA package, any AURA subsystem can then *with* this unit to access the configuration properties.

In the example above, the CLI manifest would be converted into a unit in the project root that would be declared as follows:

.. note::
  Since the AURA package is Pure, manifest packages must also be Pure. This is by design, and limits what manifest packages can do during autoconfiguration. This is both a safety/security feature, and encouragement to create AURA packages that build more efficiently and reliably.

.. code-block:: ada

  package AURA.CLI is
    ..

Manifest should contain sufficient comments to allow the user to make their own modifications to the configuration of the subsystem once :doc:`checked-out <repositories>`.



Subsystem Configuration
-----------------------

Once a subsystem manifest gets copied to the root project during the :doc:`checkout <repositories>` of an AURA subsystem, it becomes what is known as the **configuration package**. Configuration packages (while totally optional), are a powerful feature of the autoconfiguration process. 

During the build process, each subsystem is *configured*, which involves parsing and evaluating each available subsystem configuration package, and using some of the explicitly defined components to influence the build environment with code paths, external libraries, compiler settings, and C language definitions.

Here is an example of the ASAP INET subsystem which provides full TLS support as a binding to libressl's `libtls <https://www.libressl.org/>`_

.. literalinclude:: snippets/aura-inet.ads
  :language: ada
  :caption: aura-inet.ads


An AURA manifest package may contain any legal Ada declarations, and may also have a body. The only restriction is that an AURA manifest cannot have any dependencies except the Ada standard library, and my not be generic.

There are three special nested packages that the AURA implementation recognizes and processes specially, and one recommended convention.

The Configuration Nested Package
--------------------------------

.. literalinclude:: snippets/aura-inet.config-focus.ads
  :language: ada

The **configuration** nested package is not recognized by the AURA implementation, but is a recommended convention for the storage of all user-configurable options of an AURA subsystem.

In this example, the **configuration** package contains the option for enabling TLS support for the INET subsystem. The manifest should contain the default configuration.

If the user of the INET package wished to enable TLS support, they would edit the subsystem *configuration package* to enable that feature.

By following this convention, the AURA subsystem users can more easily configure their checkouts of the subsystem.

This package, if present, should declared as early as possible.

The Build Nested Package
------------------------

.. literalinclude:: snippets/aura-inet.build-externlibs.ads
  :language: ada


